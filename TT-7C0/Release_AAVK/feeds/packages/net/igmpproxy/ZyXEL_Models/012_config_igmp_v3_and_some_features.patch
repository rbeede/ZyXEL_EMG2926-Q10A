diff -ruN a/src/callout.c bb/src/callout.c
--- a/src/callout.c	2009-09-06 04:38:54.000000000 +0800
+++ bb/src/callout.c	2016-03-22 16:47:29.000000000 +0800
@@ -76,21 +76,34 @@
  */
 void age_callout_queue(int elapsed_time) {
     struct timeOutQueue *ptr;
+    struct timeOutQueue *_queue = NULL;
+    struct timeOutQueue *last = NULL;
     int i = 0;
 
-    for (ptr = queue; ptr; ptr = queue, i++) {
+    for (ptr = queue; ptr; ptr = ptr->next) {
         if (ptr->time > elapsed_time) {
             ptr->time -= elapsed_time;
-            return;
+            break;
         } else {
             elapsed_time -= ptr->time;
-            queue = queue->next;
-            my_log(LOG_DEBUG, 0, "About to call timeout %d (#%d)", ptr->id, i);
+            if (_queue == NULL)
+                _queue = ptr;
+            last = ptr;
+         }
+    }
+
+    queue = ptr;
+    if (last) {
+        last->next = NULL;
+    }
 
-            if (ptr->func)
-                ptr->func(ptr->data);
-            free(ptr);
-        }
+    /* process existing events */
+    for (ptr = _queue; ptr; ptr = _queue, i++) {
+        _queue = _queue->next;
+        my_log(LOG_DEBUG, 0, "About to call timeout %d (#%d)", ptr->id, i);
+        if (ptr->func)
+             ptr->func(ptr->data);
+        free(ptr);
     }
 }
 
diff -ruN a/src/config.c bb/src/config.c
--- a/src/config.c	2014-11-07 13:16:07.000000000 +0800
+++ bb/src/config.c	2016-03-23 10:02:53.212794640 +0800
@@ -39,33 +39,36 @@
                                       
 // Structure to keep configuration for VIFs...    
 struct vifconfig {
-    char*               name;
+    char                name[IF_NAMESIZE];
     short               state;
     int                 ratelimit;
     int                 threshold;
 
     // Keep allowed nets for VIF.
     struct SubnetList*  allowednets;
-    
+
+    // Allowed Groups
+    struct SubnetList*  allowedgroups;  
+
     // Next config in list...
     struct vifconfig*   next;
 };
                  
 // Structure to keep vif configuration
-struct vifconfig*   vifconf;
+static struct vifconfig*   vifconf;
 
 // Keeps common settings...
 static struct Config commonConfig;
 
 // Prototypes...
-struct vifconfig *parsePhyintToken();
-struct SubnetList *parseSubnetAddress(char *addrstr);
+static struct vifconfig *parsePhyintToken();
+static struct SubnetList *parseSubnetAddress(char *addrstr);
 
 
 /**
 *   Initializes common config..
 */
-void initCommonConfig() {
+static void initCommonConfig() {
     commonConfig.robustnessValue = DEFAULT_ROBUSTNESS;
     commonConfig.queryInterval = INTERVAL_QUERY;
     commonConfig.queryResponseInterval = INTERVAL_QUERY_RESPONSE;
@@ -202,7 +205,9 @@
                     // Insert the configured nets...
                     vifLast->next = confPtr->allowednets;
 
-                    break;
+		    Dp->allowedgroups = confPtr->allowedgroups;
+
+		    break;
                 }
             }
         }
@@ -213,9 +218,9 @@
 /**
 *   Internal function to parse phyint config
 */
-struct vifconfig *parsePhyintToken() {
+static struct vifconfig *parsePhyintToken() {
     struct vifconfig  *tmpPtr;
-    struct SubnetList **anetPtr;
+    struct SubnetList **anetPtr, **agrpPtr;
     char *token;
     short parseError = 0;
 
@@ -239,15 +244,13 @@
     tmpPtr->threshold = 1;
     tmpPtr->state = IF_STATE_DOWNSTREAM;
     tmpPtr->allowednets = NULL;
+    tmpPtr->allowedgroups = NULL;
 
-    // Make a copy of the token to store the IF name
-    tmpPtr->name = strdup( token );
-    if(tmpPtr->name == NULL) {
-        my_log(LOG_ERR, 0, "Out of memory.");
-    }
+    strncpy(tmpPtr->name, token, sizeof(tmpPtr->name));
 
     // Set the altnet pointer to the allowednets pointer.
     anetPtr = &tmpPtr->allowednets;
+    agrpPtr = &tmpPtr->allowedgroups;
 
     // Parse the rest of the config..
     token = nextConfigToken();
@@ -266,6 +269,20 @@
                 anetPtr = &(*anetPtr)->next;
             }
         }
+	else if(strcmp("whitelist", token)==0) {
+	    // Whitelist
+	    token = nextConfigToken();
+	    my_log(LOG_DEBUG, 0, "Config: IF: Got whitelist token %s.", token);
+	
+	    *agrpPtr = parseSubnetAddress(token);
+	    if(*agrpPtr == NULL) {
+		parseError = 1;
+		my_log(LOG_WARNING, 0, "Unable to parse subnet address.");
+		break;
+	    } else {
+		agrpPtr = &(*agrpPtr)->next;
+	    }
+	}
         else if(strcmp("upstream", token)==0) {
             // Upstream
             my_log(LOG_DEBUG, 0, "Config: IF: Got upstream token.");
@@ -312,6 +329,7 @@
 
     // Clean up after a parseerror...
     if(parseError) {
+	free(tmpPtr->name);
         free(tmpPtr);
         tmpPtr = NULL;
     }
@@ -323,7 +341,7 @@
 *   Parses a subnet address string on the format
 *   a.b.c.d/n into a SubnetList entry.
 */
-struct SubnetList *parseSubnetAddress(char *addrstr) {
+static struct SubnetList *parseSubnetAddress(char *addrstr) {
     struct SubnetList *tmpSubnet;
     char        *tmpStr;
     uint32_t      addr = 0x00000000;
diff -ruN a/src/confread.c bb/src/confread.c
--- a/src/confread.c	2009-08-16 23:01:54.000000000 +0800
+++ bb/src/confread.c	2016-03-23 10:03:00.700794739 +0800
@@ -50,12 +50,12 @@
   #define MAX_TOKEN_LENGTH  30     // Default max token length
 #endif
                                      
-FILE            *confFilePtr;       // File handle pointer
-char            *iBuffer;           // Inputbuffer for reading...
-unsigned int    bufPtr;             // Buffer position pointer.
-unsigned int    readSize;           // Number of bytes in buffer after last read...
-char    cToken[MAX_TOKEN_LENGTH];   // Token buffer...
-short   validToken;
+static FILE            *confFilePtr;       // File handle pointer
+static char            *iBuffer;           // Inputbuffer for reading...
+static unsigned int    bufPtr;             // Buffer position pointer.
+static unsigned int    readSize;           // Number of bytes in buffer after last read...
+static char    cToken[MAX_TOKEN_LENGTH];   // Token buffer...
+static short   validToken;
 
 /**
 *   Opens config file specified by filename.
diff -ruN a/src/ifvc.c bb/src/ifvc.c
--- a/src/ifvc.c	2009-10-06 02:07:06.000000000 +0800
+++ bb/src/ifvc.c	2016-03-23 10:03:07.728794833 +0800
@@ -33,7 +33,7 @@
 
 #include "igmpproxy.h"
 
-struct IfDesc IfDescVc[ MAX_IF ], *IfDescEp = IfDescVc;
+static struct IfDesc IfDescVc[ MAX_IF ], *IfDescEp = IfDescVc;
 
 /*
 ** Builds up a vector with the interface of the machine. Calls to the other functions of 
@@ -139,7 +139,7 @@
             IfDescEp->allowednets->subnet_addr = subnet;
 
             // Set the default params for the IF...
-            IfDescEp->state         = IF_STATE_DOWNSTREAM;
+            IfDescEp->state         = IF_STATE_DISABLED;
             IfDescEp->robustness    = DEFAULT_ROBUSTNESS;
             IfDescEp->threshold     = DEFAULT_THRESHOLD;   /* ttl limit */
             IfDescEp->ratelimit     = DEFAULT_RATELIMIT; 
diff -ruN a/src/igmp.c bb/src/igmp.c
--- a/src/igmp.c	2014-11-17 18:01:08.000000000 +0800
+++ bb/src/igmp.c	2016-03-23 10:05:26.892796685 +0800
@@ -36,10 +36,12 @@
 */
 
 #include "igmpproxy.h"
+#include "igmpv3.h"
  
 // Globals                  
 uint32_t     allhosts_group;          /* All hosts addr in net order */
 uint32_t     allrouters_group;          /* All hosts addr in net order */
+uint32_t     alligmp3_group;          /* IGMPv3 addr in net order */
               
 extern int MRouterFD;
 
@@ -288,25 +290,27 @@
      * - Checksum (let the kernel fill it in)
      */
     ip->ip_v   = IPVERSION;
-    ip->ip_hl  = sizeof(struct ip) >> 2;
+    ip->ip_hl  = (sizeof(struct ip) + 4) >> 2; /* +4 for Router Alert option */
     ip->ip_tos = 0xc0;      /* Internet Control */
     ip->ip_ttl = MAXTTL;    /* applies to unicasts only */
     ip->ip_p   = IPPROTO_IGMP;
 
     allhosts_group   = htonl(INADDR_ALLHOSTS_GROUP);
     allrouters_group = htonl(INADDR_ALLRTRS_GROUP);
+    alligmp3_group   = htonl(INADDR_ALLIGMPV3_GROUP);
 }
 
 /**
 *   Finds the textual name of the supplied IGMP request.
 */
-char *igmpPacketKind(u_int type, u_int code) {
+static const char *igmpPacketKind(u_int type, u_int code) {
     static char unknown[20];
 
     switch (type) {
     case IGMP_MEMBERSHIP_QUERY:     return  "Membership query  ";
     case IGMP_V1_MEMBERSHIP_REPORT:  return "V1 member report  ";
     case IGMP_V2_MEMBERSHIP_REPORT:  return "V2 member report  ";
+    case IGMP_V3_MEMBERSHIP_REPORT:  return "V3 member report  ";
     case IGMP_V2_LEAVE_GROUP:        return "Leave message     ";
     
     default:
@@ -324,7 +328,9 @@
     register uint32_t src, dst, group;
     struct ip *ip;
     struct igmp *igmp;
-    int ipdatalen, iphdrlen, igmpdatalen;
+    struct igmpv3_report *igmpv3;
+    struct igmpv3_grec *grec;
+    int ipdatalen, iphdrlen, ngrec, nsrcs;
 
     if (recvlen < sizeof(struct ip)) {
         my_log(LOG_WARNING, 0,
@@ -336,6 +342,13 @@
     src       = ip->ip_src.s_addr;
     dst       = ip->ip_dst.s_addr;
 
+    /* filter local multicast 239.255.255.250 */
+    if (dst == htonl(0xEFFFFFFA))
+    {
+        my_log(LOG_NOTICE, 0, "The IGMP message was local multicast. Ignoring.");
+        return;
+    }
+
     /* 
      * this is most likely a message from the kernel indicating that
      * a new src grp pair message has arrived and so, it would be 
@@ -385,10 +398,9 @@
         return;
     }
 
-    igmp        = (struct igmp *)(recv_buf + iphdrlen);
-    group       = igmp->igmp_group.s_addr;
-    igmpdatalen = ipdatalen - IGMP_MINLEN;
-    if (igmpdatalen < 0) {
+    igmp = (struct igmp *)(recv_buf + iphdrlen);
+    if ((ipdatalen < IGMP_MINLEN) ||
+        (igmp->igmp_type == IGMP_V3_MEMBERSHIP_REPORT && ipdatalen <= IGMPV3_MINLEN)) {
         my_log(LOG_WARNING, 0,
             "received IP data field too short (%u bytes) for IGMP, from %s",
             ipdatalen, inetFmt(src, s1));
@@ -422,10 +434,46 @@
     switch (igmp->igmp_type) {
     case IGMP_V1_MEMBERSHIP_REPORT:
     case IGMP_V2_MEMBERSHIP_REPORT:
+        group = igmp->igmp_group.s_addr;
         acceptGroupReport(src, group, igmp->igmp_type);
         return;
-    
+
+    case IGMP_V3_MEMBERSHIP_REPORT:
+        igmpv3 = (struct igmpv3_report *)(recv_buf + iphdrlen);
+        grec = &igmpv3->igmp_grec[0];
+        ngrec = ntohs(igmpv3->igmp_ngrec);
+        while (ngrec--) {
+            if ((uint8_t *)igmpv3 + ipdatalen < (uint8_t *)grec + sizeof(*grec))
+                break;
+            group = grec->grec_mca.s_addr;
+            nsrcs = ntohs(grec->grec_nsrcs);
+            switch (grec->grec_type) {
+            case IGMPV3_MODE_IS_INCLUDE:
+            case IGMPV3_CHANGE_TO_INCLUDE:
+                if (nsrcs == 0) {
+                    acceptLeaveMessage(src, group);
+                    break;
+                } /* else fall through */
+            case IGMPV3_MODE_IS_EXCLUDE:
+            case IGMPV3_CHANGE_TO_EXCLUDE:
+            case IGMPV3_ALLOW_NEW_SOURCES:
+            case IGMPV3_BLOCK_OLD_SOURCES:
+                acceptGroupReport(src, group, IGMP_V2_MEMBERSHIP_REPORT);
+                break;
+            default:
+                my_log(LOG_INFO, 0,
+                    "ignoring unknown IGMPv3 group record type %x from %s to %s for %s",
+                    grec->grec_type, inetFmt(src, s1), inetFmt(dst, s2),
+                    inetFmt(group, s3));
+                break;
+            }
+            grec = (struct igmpv3_grec *)
+                (&grec->grec_src[nsrcs] + grec->grec_auxwords * 4);
+        }
+        return;
+
     case IGMP_V2_LEAVE_GROUP:
+        group = igmp->igmp_group.s_addr;
         acceptLeaveMessage(src, group);
         return;
     
@@ -446,7 +494,7 @@
  * Construct an IGMP message in the output packet buffer.  The caller may
  * have already placed data in that buffer, of length 'datalen'.
  */
-void buildIgmp(uint32_t src, uint32_t dst, int type, int code, uint32_t group, int datalen) {
+static void buildIgmp(uint32_t src, uint32_t dst, int type, int code, uint32_t group, int datalen) {
     struct ip *ip;
     struct igmp *igmp;
     extern int curttl;
@@ -454,7 +502,7 @@
     ip                      = (struct ip *)send_buf;
     ip->ip_src.s_addr       = src;
     ip->ip_dst.s_addr       = dst;
-    ip_set_len(ip, MIN_IP_HEADER_LEN + IGMP_MINLEN + datalen);
+    ip_set_len(ip, IP_HEADER_RAOPT_LEN + IGMP_MINLEN + datalen);
 
     if (IN_MULTICAST(ntohl(dst))) {
         ip->ip_ttl = curttl;
@@ -462,13 +510,19 @@
         ip->ip_ttl = MAXTTL;
     }
 
-    igmp                    = (struct igmp *)(send_buf + MIN_IP_HEADER_LEN);
+    /* Add Router Alert option */
+    ((u_char*)send_buf+MIN_IP_HEADER_LEN)[0] = IPOPT_RA;
+    ((u_char*)send_buf+MIN_IP_HEADER_LEN)[1] = 0x04;
+    ((u_char*)send_buf+MIN_IP_HEADER_LEN)[2] = 0x00;
+    ((u_char*)send_buf+MIN_IP_HEADER_LEN)[3] = 0x00;
+
+    igmp                    = (struct igmp *)(send_buf + IP_HEADER_RAOPT_LEN);
     igmp->igmp_type         = type;
     igmp->igmp_code         = code;
     igmp->igmp_group.s_addr = group;
     igmp->igmp_cksum        = 0;
     igmp->igmp_cksum        = inetChksum((u_short *)igmp,
-                                         IGMP_MINLEN + datalen);
+                                         IP_HEADER_RAOPT_LEN + datalen);
 }
 
 /* 
@@ -498,7 +552,7 @@
 #endif
     sdst.sin_addr.s_addr = dst;
     if (sendto(MRouterFD, send_buf,
-               MIN_IP_HEADER_LEN + IGMP_MINLEN + datalen, 0,
+               IP_HEADER_RAOPT_LEN + IGMP_MINLEN + datalen, 0,
                (struct sockaddr *)&sdst, sizeof(sdst)) < 0) {
         if (errno == ENETDOWN)
             my_log(LOG_ERR, errno, "Sender VIF was down.");
diff -ruN a/src/igmpproxy.c bb/src/igmpproxy.c
--- a/src/igmpproxy.c	2014-11-17 17:17:00.000000000 +0800
+++ bb/src/igmpproxy.c	2016-03-23 10:10:04.900800385 +0800
@@ -37,6 +37,7 @@
 */
 
 #include "igmpproxy.h"
+#include <sys/sysinfo.h>
 
 static const char Usage[] = 
 "Usage: igmpproxy [-h] [-d] [-v [-v]] <configfile>\n"
@@ -50,9 +51,9 @@
 
 // Local function Prototypes
 static void signalHandler(int);
-int     igmpProxyInit();
-void    igmpProxyCleanUp();
-void    igmpProxyRun();
+static int  igmpProxyInit();
+static void igmpProxyCleanUp();
+static void igmpProxyRun();
 
 #if defined(ZYXEL_IGMP_STATUS)
 extern void console_printf(char *str);
@@ -76,17 +77,16 @@
 */    
 int main( int ArgCn, char *ArgVc[] ) {
 
+    int c;
+
     // Parse the commandline options and setup basic settings..
-    for (int c; (c = getopt(ArgCn, ArgVc, "vdh")) != -1;) {
+    while ((c = getopt(ArgCn, ArgVc, "vdh")) != -1) {
         switch (c) {
         case 'd':
             Log2Stderr = true;
             break;
         case 'v':
-            if (LogLevel == LOG_INFO)
-                LogLevel = LOG_DEBUG;
-            else
-                LogLevel = LOG_INFO;
+            LogLevel++;
             break;
         case 'h':
             fputs(Usage, stderr);
@@ -129,6 +129,13 @@
             break;
         }
 
+	if ( !Log2Stderr ) {
+	    if ( daemon(1, 0) < 0 ) {
+		my_log( LOG_ERR, errno, "failed to detach daemon" );
+		exit(errno);
+	    }
+	}
+
         // Go to the main loop.
         igmpProxyRun();
     
@@ -151,7 +158,7 @@
 /**
 *   Handles the initial startup of the daemon.
 */
-int igmpProxyInit() {
+static int igmpProxyInit() {
     struct sigaction sa;
     int Err;
 
@@ -184,7 +191,7 @@
 
         for ( Ix = 0; (Dp = getIfByIx(Ix)); Ix++ ) {
 
-            if ( Dp->InAdr.s_addr && ! (Dp->Flags & IFF_LOOPBACK) ) {
+            if ( Dp->InAdr.s_addr && ! (Dp->Flags & IFF_LOOPBACK) && Dp->state != IF_STATE_DISABLED ) {
                 if(Dp->state == IF_STATE_UPSTREAM) {
                     if(upStreamVif == -1) {
                         upStreamVif = Ix;
@@ -219,7 +226,7 @@
 /**
 *   Clean up all on exit...
 */
-void igmpProxyCleanUp() {
+static void igmpProxyCleanUp() {
 
     my_log( LOG_DEBUG, 0, "clean handler called" );
     
@@ -229,10 +236,20 @@
 
 }
 
+static void getuptime(struct timeval *tv)
+{
+    struct sysinfo si;
+
+    sysinfo(&si);
+
+    tv->tv_sec = si.uptime;
+    tv->tv_usec = 0;
+}
+
 /**
 *   Main daemon loop.
 */
-void igmpProxyRun() {
+static void igmpProxyRun() {
     // Get the config.
     //struct Config *config = getCommonConfig();
     // Set some needed values.
@@ -246,7 +263,7 @@
 
     // Initialize timer vars
     difftime.tv_usec = 0;
-    gettimeofday(&curtime, NULL);
+    getuptime(&curtime);
     lasttime = curtime;
 
     // First thing we send a membership query in downstream VIF's...
@@ -284,7 +301,7 @@
 
         // log and ignore failures
         if( Rt < 0 ) {
-            my_log( LOG_WARNING, errno, "select() failure" );
+            if (errno != EINTR) my_log( LOG_WARNING, errno, "select() failure" );
             continue;
         }
         else if( Rt > 0 ) {
@@ -309,14 +326,14 @@
             /*
              * If the select timed out, then there's no other
              * activity to account for and we don't need to
-             * call gettimeofday.
+             * call getuptime.
              */
             if (Rt == 0) {
                 curtime.tv_sec = lasttime.tv_sec + secs;
                 curtime.tv_usec = lasttime.tv_usec;
                 Rt = -1; /* don't do this next time through the loop */
             } else {
-                gettimeofday(&curtime, NULL);
+                getuptime(&curtime);
             }
             difftime.tv_sec = curtime.tv_sec - lasttime.tv_sec;
             difftime.tv_usec += curtime.tv_usec - lasttime.tv_usec;
diff -ruN a/src/igmpproxy.h bb/src/igmpproxy.h
--- a/src/igmpproxy.h	2014-11-17 17:47:00.000000000 +0800
+++ bb/src/igmpproxy.h	2016-03-23 10:46:45.776829678 +0800
@@ -64,6 +64,7 @@
 #define MAX_IP_PACKET_LEN	576
 #define MIN_IP_HEADER_LEN	20
 #define MAX_IP_HEADER_LEN	60
+#define IP_HEADER_RAOPT_LEN	24
 
 #define MAX_MC_VIFS    32     // !!! check this const in the specific includes
 
@@ -94,6 +95,40 @@
 extern char		s3[];
 extern char		s4[];
 
+#if defined(ZYXEL_IGMP_STATUS)
+
+#define MZERO(x,y) memset(x,0,y)
+#define FAILURE -1
+#define SUCCESS   1 
+#define IGMP_MULTICAST_GROUP 1
+#define IGMP_LAN_HOST 2
+#define IGMP_MAX 256
+
+typedef struct timer_event_t timer_event_t;
+struct timer_event_t {
+	time_t timestamp;
+	time_t min_timestamp;
+	void (*handler) (void *_data);
+	void *data;
+	short disable;
+	timer_event_t *next;
+};
+
+typedef struct igmp_db_data igmp_db_data;
+struct igmp_db_data
+{
+	unsigned short igmp_type;	
+	uint32_t ip_index;
+	char time[64];
+	time_t time2;
+	unsigned int   join;
+	unsigned int   leave;
+
+	igmp_db_data *next;
+
+};
+#endif
+
 
 
 //#################################################################################
@@ -144,11 +179,12 @@
     struct in_addr      InAdr;          /* == 0 for non IP interfaces */            
     short               Flags;
     short               state;
+    short               index;
+    uint8_t             robustness;
+    uint8_t             threshold;   /* ttl limit */
+    unsigned int        ratelimit;
     struct SubnetList*  allowednets;
-    unsigned int        robustness;
-    unsigned char       threshold;   /* ttl limit */
-    unsigned int        ratelimit; 
-    unsigned int        index;
+    struct SubnetList*  allowedgroups;
 };
 
 // Keeps common configuration settings 
@@ -163,7 +199,7 @@
     unsigned int        lastMemberQueryInterval;
     unsigned int        lastMemberQueryCount;
     // Set if upstream leave messages should be sent instantly..
-    unsigned short      fastUpstreamLeave;
+    unsigned int      fastUpstreamLeave;
 };
 
 // Defines the Index of the upstream VIF...
@@ -174,15 +210,15 @@
 void buildIfVc( void );
 struct IfDesc *getIfByName( const char *IfName );
 struct IfDesc *getIfByIx( unsigned Ix );
-struct IfDesc *getIfByAddress( uint32_t Ix );
+struct IfDesc *getIfByAddress( uint32_t ipaddr );
 int isAdressValidForIf(struct IfDesc* intrface, uint32_t ipaddr);
 
 /* mroute-api.c
  */
 struct MRouteDesc {
+    vifi_t          InVif;
+    uint8_t         TtlVc[ MAX_MC_VIFS ];
     struct in_addr  OriginAdr, McAdr;
-    short           InVif;
-    uint8_t           TtlVc[ MAX_MC_VIFS ];
 };
 
 // IGMP socket as interface for the mrouted API
@@ -206,6 +242,7 @@
 */
 extern uint32_t allhosts_group;
 extern uint32_t allrouters_group;
+extern uint32_t alligmp3_group;
 void initIgmp(void);
 void acceptIgmp(int);
 void sendIgmp (uint32_t, uint32_t, int, int, uint32_t,int);
@@ -229,14 +266,36 @@
 void k_leave(uint32_t grp, uint32_t ifa);
 */
 
-/* udpsock.c
- */
-int openUdpSocket( uint32_t PeerInAdr, uint16_t PeerPort );
-
 /* mcgroup.c
  */
-int joinMcGroup( int UdpSock, struct IfDesc *IfDp, uint32_t mcastaddr );
-int leaveMcGroup( int UdpSock, struct IfDesc *IfDp, uint32_t mcastaddr );
+extern int joinleave( int Cmd, int UdpSock, struct IfDesc *IfDp, uint32_t mcastaddr );
+/**
+*   Joins the MC group with the address 'McAdr' on the interface 'IfName'. 
+*   The join is bound to the UDP socket 'UdpSock', so if this socket is 
+*   closed the membership is dropped.
+*          
+*   @return 0 if the function succeeds, 1 if parameters are wrong or the join fails
+*/
+static inline int joinMcGroup( int UdpSock, struct IfDesc *IfDp, uint32_t mcastaddr ) {
+
+#if defined(ZYXEL_IGMP_STATUS)
+	igmp_db_add(IGMP_MULTICAST_GROUP ,mcastaddr , 1);
+#endif
+    return joinleave( 'j', UdpSock, IfDp, mcastaddr );
+}
+
+/**
+*   Leaves the MC group with the address 'McAdr' on the interface 'IfName'. 
+*          
+*   @return 0 if the function succeeds, 1 if parameters are wrong or the join fails
+*/
+static inline int leaveMcGroup( int UdpSock, struct IfDesc *IfDp, uint32_t mcastaddr ) {
+
+#if defined(ZYXEL_IGMP_STATUS)
+	igmp_db_add(IGMP_MULTICAST_GROUP,mcastaddr , 0);
+#endif
+    return joinleave( 'l', UdpSock, IfDp, mcastaddr );
+}
 
 
 /* rttable.c
@@ -277,37 +336,5 @@
 char* getCurrentConfigToken();
 
 
-#if defined(ZYXEL_IGMP_STATUS)
-
-#define MZERO(x,y) memset(x,0,y)
-#define FAILURE -1
-#define SUCCESS   1 
-#define IGMP_MULTICAST_GROUP 1
-#define IGMP_LAN_HOST 2
-#define IGMP_MAX 256
-
-typedef struct timer_event_t timer_event_t;
-struct timer_event_t {
-	time_t timestamp;
-	time_t min_timestamp;
-	void (*handler) (void *_data);
-	void *data;
-	short disable;
-	timer_event_t *next;
-};
-
-typedef struct igmp_db_data igmp_db_data;
-struct igmp_db_data
-{
-	unsigned short igmp_type;	
-	uint32_t ip_index;
-	char time[64];
-	time_t time2;
-	unsigned int   join;
-	unsigned int   leave;
-
-	igmp_db_data *next;
 
-};
-#endif
 
diff -ruN a/src/igmpv3.h bb/src/igmpv3.h
--- a/src/igmpv3.h	1970-01-01 08:00:00.000000000 +0800
+++ bb/src/igmpv3.h	2016-03-23 09:51:46.000000000 +0800
@@ -0,0 +1,48 @@
+/*
+**  igmpproxy - IGMP proxy based multicast router 
+**  Copyright (C) 2005 Johnny Egeland <johnny@rlo.org>
+**
+**  This program is free software; you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation; either version 2 of the License, or
+**  (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**
+**  You should have received a copy of the GNU General Public License
+**  along with this program; if not, write to the Free Software
+**  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+**
+*/
+/**
+*   igmpv3.h - Header file for common IGMPv3 includes.
+*/
+
+struct igmpv3_grec {
+    u_int8_t grec_type;
+    u_int8_t grec_auxwords;
+    u_int16_t grec_nsrcs;
+    struct in_addr grec_mca;
+    struct in_addr grec_src[0];
+};
+
+struct igmpv3_report {
+    u_int8_t igmp_type;
+    u_int8_t igmp_resv1;
+    u_int16_t igmp_cksum;
+    u_int16_t igmp_resv2;
+    u_int16_t igmp_ngrec;
+    struct igmpv3_grec igmp_grec[0];
+};
+
+#define IGMPV3_MODE_IS_INCLUDE   1
+#define IGMPV3_MODE_IS_EXCLUDE   2
+#define IGMPV3_CHANGE_TO_INCLUDE 3
+#define IGMPV3_CHANGE_TO_EXCLUDE 4
+#define IGMPV3_ALLOW_NEW_SOURCES 5
+#define IGMPV3_BLOCK_OLD_SOURCES 6
+
+#define IGMPV3_MINLEN 12
diff -ruN a/src/Makefile.am bb/src/Makefile.am
--- a/src/Makefile.am	2009-10-06 00:41:47.000000000 +0800
+++ bb/src/Makefile.am	2016-03-23 09:57:51.992790631 +0800
@@ -5,6 +5,7 @@
 	confread.c \
 	ifvc.c \
 	igmp.c \
+	igmpv3.h \
 	igmpproxy.c \
 	igmpproxy.h \
 	kern.c \
@@ -18,5 +19,4 @@
 	os-openbsd.h \
 	request.c \
 	rttable.c \
-	syslog.c \
-	udpsock.c
+	syslog.c
diff -ruN a/src/Makefile.in bb/src/Makefile.in
--- a/src/Makefile.in	2009-10-06 02:19:42.000000000 +0800
+++ bb/src/Makefile.in	2016-03-23 09:58:23.020791044 +0800
@@ -51,7 +51,7 @@
 	confread.$(OBJEXT) ifvc.$(OBJEXT) igmp.$(OBJEXT) \
 	igmpproxy.$(OBJEXT) kern.$(OBJEXT) lib.$(OBJEXT) \
 	mcgroup.$(OBJEXT) mroute-api.$(OBJEXT) request.$(OBJEXT) \
-	rttable.$(OBJEXT) syslog.$(OBJEXT) udpsock.$(OBJEXT)
+	rttable.$(OBJEXT) syslog.$(OBJEXT)
 igmpproxy_OBJECTS = $(am_igmpproxy_OBJECTS)
 igmpproxy_LDADD = $(LDADD)
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
@@ -163,6 +163,7 @@
 	confread.c \
 	ifvc.c \
 	igmp.c \
+	igmpv3.h \
 	igmpproxy.c \
 	igmpproxy.h \
 	kern.c \
@@ -176,8 +177,7 @@
 	os-openbsd.h \
 	request.c \
 	rttable.c \
-	syslog.c \
-	udpsock.c
+	syslog.c
 
 all: all-am
 
@@ -273,7 +273,6 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/request.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rttable.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/syslog.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/udpsock.Po@am__quote@
 
 .c.o:
 @am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
diff -ruN a/src/mcgroup.c bb/src/mcgroup.c
--- a/src/mcgroup.c	2014-11-17 17:18:05.000000000 +0800
+++ bb/src/mcgroup.c	2016-03-23 10:15:32.536804746 +0800
@@ -44,7 +44,7 @@
 /**
 *   Common function for joining or leaving a MCast group.
 */
-static int joinleave( int Cmd, int UdpSock, struct IfDesc *IfDp, uint32_t mcastaddr ) {
+int joinleave( int Cmd, int UdpSock, struct IfDesc *IfDp, uint32_t mcastaddr ) {
     struct ip_mreq CtlReq;
     const char *CmdSt = Cmd == 'j' ? "join" : "leave";
     
@@ -68,32 +68,3 @@
     return 0;
 }
 
-/**
-*   Joins the MC group with the address 'McAdr' on the interface 'IfName'. 
-*   The join is bound to the UDP socket 'UdpSock', so if this socket is 
-*   closed the membership is dropped.
-*          
-*   @return 0 if the function succeeds, 1 if parameters are wrong or the join fails
-*/
-int joinMcGroup( int UdpSock, struct IfDesc *IfDp, uint32_t mcastaddr ) {
-	
-#if defined(ZYXEL_IGMP_STATUS)
-	igmp_db_add(IGMP_MULTICAST_GROUP ,mcastaddr , 1);
-#endif
-
-    return joinleave( 'j', UdpSock, IfDp, mcastaddr );
-}
-
-/**
-*   Leaves the MC group with the address 'McAdr' on the interface 'IfName'. 
-*          
-*   @return 0 if the function succeeds, 1 if parameters are wrong or the join fails
-*/
-int leaveMcGroup( int UdpSock, struct IfDesc *IfDp, uint32_t mcastaddr ) {
-	
-#if defined(ZYXEL_IGMP_STATUS)
-	igmp_db_add(IGMP_MULTICAST_GROUP,mcastaddr , 0);
-#endif
-
-    return joinleave( 'l', UdpSock, IfDp, mcastaddr );
-}
diff -ruN a/src/mroute-api.c bb/src/mroute-api.c
--- a/src/mroute-api.c	2009-05-14 03:43:18.000000000 +0800
+++ bb/src/mroute-api.c	2016-03-23 10:15:52.080805006 +0800
@@ -46,7 +46,7 @@
      
 // need an IGMP socket as interface for the mrouted API
 // - receives the IGMP messages
-int         MRouterFD;        /* socket for all network I/O  */
+int         MRouterFD = -1;      /* socket for all network I/O  */
 char        *recv_buf;           /* input packet buffer         */
 char        *send_buf;           /* output packet buffer        */
 
diff -ruN a/src/os-dragonfly.h bb/src/os-dragonfly.h
--- a/src/os-dragonfly.h	2009-05-14 03:43:18.000000000 +0800
+++ bb/src/os-dragonfly.h	2016-03-22 17:16:49.000000000 +0800
@@ -3,6 +3,10 @@
 #include <netinet/ip.h>
 #include <netinet/igmp.h>
 
+#define IGMP_V3_MEMBERSHIP_REPORT 0x22
+
+#define INADDR_ALLIGMPV3_GROUP ((in_addr_t) 0xe0000016)
+
 static inline u_short ip_data_len(const struct ip *ip)
 {
 	return ip->ip_len;
diff -ruN a/src/os-freebsd.h bb/src/os-freebsd.h
--- a/src/os-freebsd.h	2009-10-06 02:07:06.000000000 +0800
+++ bb/src/os-freebsd.h	2016-03-22 17:17:15.000000000 +0800
@@ -12,6 +12,10 @@
 #define IGMP_V2_LEAVE_GROUP IGMP_HOST_LEAVE_MESSAGE
 #endif
 
+#define IGMP_V3_MEMBERSHIP_REPORT 0x22
+
+#define INADDR_ALLIGMPV3_GROUP ((in_addr_t) 0xe0000016)
+
 static inline u_short ip_data_len(const struct ip *ip)
 {
 	return ip->ip_len;
diff -ruN a/src/os-linux.h bb/src/os-linux.h
--- a/src/os-linux.h	2014-11-07 13:16:09.000000000 +0800
+++ bb/src/os-linux.h	2016-03-22 17:17:50.000000000 +0800
@@ -4,6 +4,10 @@
 #include <netinet/ip.h>
 #include <netinet/igmp.h>
 
+#define IGMP_V3_MEMBERSHIP_REPORT 0x22
+
+#define INADDR_ALLIGMPV3_GROUP ((in_addr_t) 0xe0000016)
+
 static inline u_short ip_data_len(const struct ip *ip)
 {
 	return ntohs(ip->ip_len) - (ip->ip_hl << 2);
diff -ruN a/src/os-netbsd.h bb/src/os-netbsd.h
--- a/src/os-netbsd.h	2009-05-14 03:43:18.000000000 +0800
+++ bb/src/os-netbsd.h	2016-03-22 17:18:31.000000000 +0800
@@ -6,8 +6,11 @@
 #define IGMP_MEMBERSHIP_QUERY IGMP_HOST_MEMBERSHIP_QUERY
 #define IGMP_V1_MEMBERSHIP_REPORT IGMP_v1_HOST_MEMBERSHIP_REPORT
 #define IGMP_V2_MEMBERSHIP_REPORT IGMP_v2_HOST_MEMBERSHIP_REPORT
+#define IGMP_V3_MEMBERSHIP_REPORT 0x22
 #define IGMP_V2_LEAVE_GROUP IGMP_HOST_LEAVE_MESSAGE
 
+#define INADDR_ALLIGMPV3_GROUP ((in_addr_t) 0xe0000016)
+
 static inline u_short ip_data_len(const struct ip *ip)
 {
 	return ip->ip_len;
diff -ruN a/src/os-openbsd.h bb/src/os-openbsd.h
--- a/src/os-openbsd.h	2009-05-14 03:43:18.000000000 +0800
+++ bb/src/os-openbsd.h	2016-03-22 17:18:54.000000000 +0800
@@ -6,9 +6,11 @@
 #define IGMP_MEMBERSHIP_QUERY IGMP_HOST_MEMBERSHIP_QUERY
 #define IGMP_V1_MEMBERSHIP_REPORT IGMP_v1_HOST_MEMBERSHIP_REPORT
 #define IGMP_V2_MEMBERSHIP_REPORT IGMP_v2_HOST_MEMBERSHIP_REPORT
+#define IGMP_V3_MEMBERSHIP_REPORT 0x22
 #define IGMP_V2_LEAVE_GROUP IGMP_HOST_LEAVE_MESSAGE
 
 #define INADDR_ALLRTRS_GROUP INADDR_ALLROUTERS_GROUP
+#define INADDR_ALLIGMPV3_GROUP ((in_addr_t) 0xe0000016)
 
 static inline u_short ip_data_len(const struct ip *ip)
 {
diff -ruN a/src/request.c bb/src/request.c
--- a/src/request.c	2009-10-06 02:19:26.000000000 +0800
+++ bb/src/request.c	2016-03-23 10:16:21.292805395 +0800
@@ -40,7 +40,7 @@
 #include "igmpproxy.h"
 
 // Prototypes...
-void sendGroupSpecificMemberQuery(void *argument);  
+static void sendGroupSpecificMemberQuery(void *argument);  
     
 typedef struct {
     uint32_t      group;
@@ -82,13 +82,26 @@
         my_log(LOG_DEBUG, 0, "Should insert group %s (from: %s) to route table. Vif Ix : %d",
             inetFmt(group,s1), inetFmt(src,s2), sourceVif->index);
 
-        // The membership report was OK... Insert it into the route table..
-        insertRoute(group, sourceVif->index);
-
+	// If we don't have a whitelist we insertRoute and done
+	if(sourceVif->allowedgroups == NULL)
+	{
+	    insertRoute(group, sourceVif->index);
+	    return;
+	}
+	// Check if this Request is legit on this interface
+	struct SubnetList *sn;
+	for(sn = sourceVif->allowedgroups; sn != NULL; sn = sn->next)
+	    if((group & sn->subnet_mask) == sn->subnet_addr)
+	    {
+        	// The membership report was OK... Insert it into the route table..
+        	insertRoute(group, sourceVif->index);
+		return;
+	    }
+	my_log(LOG_INFO, 0, "The group address %s may not be requested from this interface. Ignoring.", inetFmt(group, s1));
 
     } else {
         // Log the state of the interface the report was recieved on.
-        my_log(LOG_INFO, 0, "Mebership report was recieved on %s. Ignoring.",
+        my_log(LOG_INFO, 0, "Membership report was recieved on %s. Ignoring.",
             sourceVif->state==IF_STATE_UPSTREAM?"the upstream interface":"a disabled interface");
     }
 
@@ -145,7 +158,7 @@
 *   Sends a group specific member report query until the 
 *   group times out...
 */
-void sendGroupSpecificMemberQuery(void *argument) {
+static void sendGroupSpecificMemberQuery(void *argument) {
     struct  Config  *conf = getCommonConfig();
 
     // Cast argument to correct type...
@@ -182,7 +195,7 @@
 void sendGeneralMembershipQuery() {
     struct  Config  *conf = getCommonConfig();
     struct  IfDesc  *Dp;
-    int             Ix;
+    unsigned             Ix;
 
     // Loop through all downstream vifs...
     for ( Ix = 0; (Dp = getIfByIx(Ix)); Ix++ ) {
diff -ruN a/src/rttable.c bb/src/rttable.c
--- a/src/rttable.c	2009-05-14 03:43:18.000000000 +0800
+++ bb/src/rttable.c	2016-03-23 10:18:01.172806724 +0800
@@ -38,7 +38,9 @@
 */
 
 #include "igmpproxy.h"
-    
+
+#define MAX_ORIGINS 4
+
 /**
 *   Routing table structure definition. Double linked list...
 */
@@ -46,7 +48,7 @@
     struct RouteTable   *nextroute;     // Pointer to the next group in line.
     struct RouteTable   *prevroute;     // Pointer to the previous group in line.
     uint32_t              group;          // The group to route
-    uint32_t              originAddr;     // The origin adress (only set on activated routes)
+    uint32_t              originAddrs[MAX_ORIGINS]; // The origin adresses (only set on activated routes)
     uint32_t              vifBits;        // Bits representing recieving VIFs.
 
     // Keeps the upstream membership state...
@@ -63,25 +65,12 @@
 static struct RouteTable   *routing_table;
 
 // Prototypes
-void logRouteTable(char *header);
-int  internAgeRoute(struct RouteTable*  croute);
-int internUpdateKernelRoute(struct RouteTable *route, int activate);
-
-// Socket for sending join or leave requests.
-int mcGroupSock = 0;
+static void logRouteTable(char *header);
+static int  internAgeRoute(struct RouteTable*  croute);
+static int internUpdateKernelRoute(struct RouteTable *route, int activate);
 
 
 /**
-*   Function for retrieving the Multicast Group socket.
-*/
-int getMcGroupSock() {
-    if( ! mcGroupSock ) {
-        mcGroupSock = openUdpSocket( INADDR_ANY, 0 );;
-    }
-    return mcGroupSock;
-}
- 
-/**
 *   Initializes the routing table.
 */
 void initRouteTable() {
@@ -99,7 +88,11 @@
                          inetFmt(allrouters_group,s1),inetFmt(Dp->InAdr.s_addr,s2));
             
             //k_join(allrouters_group, Dp->InAdr.s_addr);
-            joinMcGroup( getMcGroupSock(), Dp, allrouters_group );
+            joinMcGroup( MRouterFD, Dp, allrouters_group );
+
+            my_log(LOG_DEBUG, 0, "Joining all igmpv3 multicast routers group %s on vif %s",
+                         inetFmt(alligmp3_group,s1),inetFmt(Dp->InAdr.s_addr,s2));
+            joinMcGroup( MRouterFD, Dp, alligmp3_group );
         }
     }
 }
@@ -108,7 +101,7 @@
 *   Internal function to send join or leave requests for
 *   a specified route upstream...
 */
-void sendJoinLeaveUpstream(struct RouteTable* route, int join) {
+static void sendJoinLeaveUpstream(struct RouteTable* route, int join) {
     struct IfDesc*      upstrIf;
     
     // Get the upstream VIF...
@@ -117,6 +110,23 @@
         my_log(LOG_ERR, 0 ,"FATAL: Unable to get Upstream IF.");
     }
 
+    // Check if there is a white list for the upstram VIF
+    if (upstrIf->allowedgroups != NULL) {
+      uint32_t           group = route->group;
+        struct SubnetList* sn;
+
+        // Check if this Request is legit to be forwarded to upstream
+        for(sn = upstrIf->allowedgroups; sn != NULL; sn = sn->next)
+            if((group & sn->subnet_mask) == sn->subnet_addr)
+                // Forward is OK...
+                break;
+
+        if (sn == NULL) {
+	    my_log(LOG_INFO, 0, "The group address %s may not be forwarded upstream. Ignoring.", inetFmt(group, s1));
+            return;
+        }
+    }
+
     // Send join or leave request...
     if(join) {
 
@@ -127,7 +137,7 @@
                          inetFmt(upstrIf->InAdr.s_addr, s2));
 
             //k_join(route->group, upstrIf->InAdr.s_addr);
-            joinMcGroup( getMcGroupSock(), upstrIf, route->group );
+            joinMcGroup( MRouterFD, upstrIf, route->group );
 
             route->upstrState = ROUTESTATE_JOINED;
         } else {
@@ -143,7 +153,7 @@
                          inetFmt(upstrIf->InAdr.s_addr, s2));
             
             //k_leave(route->group, upstrIf->InAdr.s_addr);
-            leaveMcGroup( getMcGroupSock(), upstrIf, route->group );
+            leaveMcGroup( MRouterFD, upstrIf, route->group );
 
             route->upstrState = ROUTESTATE_NOTJOINED;
         }
@@ -235,7 +245,7 @@
         newroute = (struct RouteTable*)malloc(sizeof(struct RouteTable));
         // Insert the route desc and clear all pointers...
         newroute->group      = group;
-        newroute->originAddr = 0;
+        memset(newroute->originAddrs, 0, MAX_ORIGINS * sizeof(newroute->originAddrs[0]));
         newroute->nextroute  = NULL;
         newroute->prevroute  = NULL;
 
@@ -318,14 +328,10 @@
         my_log(LOG_INFO, 0, "Updated route entry for %s on VIF #%d",
             inetFmt(croute->group, s1), ifx);
 
-        // If the route is active, it must be reloaded into the Kernel..
-        if(croute->originAddr != 0) {
-
-            // Update route in kernel...
-            if(!internUpdateKernelRoute(croute, 1)) {
-                my_log(LOG_WARNING, 0, "The insertion into Kernel failed.");
-                return 0;
-            }
+        // Update route in kernel...
+        if(!internUpdateKernelRoute(croute, 1)) {
+            my_log(LOG_WARNING, 0, "The insertion into Kernel failed.");
+            return 0;
         }
     }
 
@@ -366,13 +372,35 @@
     if(croute != NULL) {
         // If the origin address is set, update the route data.
         if(originAddr > 0) {
-            if(croute->originAddr > 0 && croute->originAddr!=originAddr) {
-                my_log(LOG_WARNING, 0, "The origin for route %s changed from %s to %s",
+            // find this origin, or an unused slot
+            int i;
+            for (i = 0; i < MAX_ORIGINS; i++) {
+                // unused slots are at the bottom, so we can't miss this origin
+                if (croute->originAddrs[i] == originAddr || croute->originAddrs[i] == 0) {
+                    break;
+                }
+            }
+            
+            if (i == MAX_ORIGINS) {
+                i = MAX_ORIGINS - 1;
+                
+                my_log(LOG_WARNING, 0, "Too many origins for route %s; replacing %s with %s",
                     inetFmt(croute->group, s1),
-                    inetFmt(croute->originAddr, s2),
+                    inetFmt(croute->originAddrs[i], s2),
                     inetFmt(originAddr, s3));
             }
-            croute->originAddr = originAddr;
+           // croute->originAddr = originAddr;
+            
+            // set origin
+            croute->originAddrs[i] = originAddr;
+            
+            // move it to the top
+            while (i > 0) {
+                uint32_t t = croute->originAddrs[i - 1];
+                croute->originAddrs[i - 1] = croute->originAddrs[i];
+                croute->originAddrs[i] = t;
+                i--;
+            }
         }
 
         // Only update kernel table if there are listeners !
@@ -455,7 +483,7 @@
 *   Remove a specified route. Returns 1 on success,
 *   and 0 if route was not found.
 */
-int removeRoute(struct RouteTable*  croute) {
+static int removeRoute(struct RouteTable*  croute) {
     struct Config       *conf = getCommonConfig();
     int result = 1;
     
@@ -510,7 +538,7 @@
 /**
 *   Ages a specific route
 */
-int internAgeRoute(struct RouteTable*  croute) {
+static int internAgeRoute(struct RouteTable*  croute) {
     struct Config *conf = getCommonConfig();
     int result = 0;
 
@@ -581,17 +609,21 @@
 *   Updates the Kernel routing table. If activate is 1, the route
 *   is (re-)activated. If activate is false, the route is removed.
 */
-int internUpdateKernelRoute(struct RouteTable *route, int activate) {
+static int internUpdateKernelRoute(struct RouteTable *route, int activate) {
     struct   MRouteDesc     mrDesc;
     struct   IfDesc         *Dp;
     unsigned                Ix;
+    int                     i;
+    
+    for (i = 0; i < MAX_ORIGINS; i++) {
+        if (route->originAddrs[i] == 0) {
+            continue;
+        }
     
-    if(route->originAddr>0) {
-
         // Build route descriptor from table entry...
         // Set the source address and group address...
         mrDesc.McAdr.s_addr     = route->group;
-        mrDesc.OriginAdr.s_addr = route->originAddr;
+        mrDesc.OriginAdr.s_addr = route->originAddrs[i];
     
         // clear output interfaces 
         memset( mrDesc.TtlVc, 0, sizeof( mrDesc.TtlVc ) );
@@ -618,9 +650,6 @@
             // Delete the route from Kernel...
             delMRoute( &mrDesc );
         }
-
-    } else {
-        my_log(LOG_NOTICE, 0, "Route is not active. No kernel updates done.");
     }
 
     return 1;
@@ -630,9 +659,10 @@
 *   Debug function that writes the routing table entries
 *   to the log.
 */
-void logRouteTable(char *header) {
+static void logRouteTable(char *header) {
         struct RouteTable*  croute = routing_table;
         unsigned            rcount = 0;
+        int                 i;
     
         my_log(LOG_DEBUG, 0, "");
         my_log(LOG_DEBUG, 0, "Current routing table (%s):", header);
@@ -641,15 +671,21 @@
             my_log(LOG_DEBUG, 0, "No routes in table...");
         } else {
             do {
-                /*
-                my_log(LOG_DEBUG, 0, "#%d: Src: %s, Dst: %s, Age:%d, St: %s, Prev: 0x%08x, T: 0x%08x, Next: 0x%08x",
-                    rcount, inetFmt(croute->originAddr, s1), inetFmt(croute->group, s2),
-                    croute->ageValue,(croute->originAddr>0?"A":"I"),
-                    croute->prevroute, croute, croute->nextroute);
-                */
-                my_log(LOG_DEBUG, 0, "#%d: Src: %s, Dst: %s, Age:%d, St: %s, OutVifs: 0x%08x",
-                    rcount, inetFmt(croute->originAddr, s1), inetFmt(croute->group, s2),
-                    croute->ageValue,(croute->originAddr>0?"A":"I"),
+                char st = 'I';
+                char src[MAX_ORIGINS * 30 + 1];
+                src[0] = '\0';
+                
+                for (i = 0; i < MAX_ORIGINS; i++) {
+                    if (croute->originAddrs[i] == 0) {
+                        continue;
+                    }
+                    st = 'A';
+                    sprintf(src + strlen(src), "Src%d: %s, ", i, inetFmt(croute->originAddrs[i], s1));
+                }
+                
+                my_log(LOG_DEBUG, 0, "#%d: %sDst: %s, Age:%d, St: %c, OutVifs: 0x%08x",
+                    rcount, src, inetFmt(croute->group, s2),
+                    croute->ageValue, st,
                     croute->vifBits);
                   
                 croute = croute->nextroute; 
diff -ruN a/src/syslog.c bb/src/syslog.c
--- a/src/syslog.c	2009-05-14 03:43:18.000000000 +0800
+++ bb/src/syslog.c	2016-03-22 17:08:33.000000000 +0800
@@ -33,7 +33,7 @@
 
 #include "igmpproxy.h"
 
-int LogLevel = LOG_WARNING;
+int LogLevel = LOG_ERR;
 bool Log2Stderr = false;
 
 void my_log( int Severity, int Errno, const char *FmtSt, ... )
